---
title: "Pre-processing valiDrops"
params: 
  patient: "P1"
  resolution: 0.1
  mito_gene_percent: 10
  directory: "/home/a.blanc-boekholt/Documents/Singlecell-R"
  file: "raw_feature_bc_matrix.h5"
format: html
editor: visual
---

## Steps of this pre-processing, valiDrops, Seurat and DoubletFinder

-   Downloading the raw data by 10X Genomics pipeline and merging all days into one Seurat object.

-   Applying the **valiDrops** tool. This tool performs quality control on single-cell data by identifying valid barcodes and predicting whether each cell is alive or dead, based on expression profiles and quality metrics. It's a quality control and filtering steps.

-   Removing non-coding genes using **Ensembl** gene annotations (via a reusable custom function).

-   Detecting doublets (Singlet or Doublet) using **DoubletFinder** on each day separately, then adding this metadata to the merged object and removing doublets (also done via a reusable function).

-   Selecting the top 2000 variable genes, normalization, and scaling using **Seurat**.

-   Visualizations: PCA, Heatmap, and UMAP (resolution 0.1)

## Data and libraries initialization

```{r}
#| message: false
library(SeuratObject)
library(sp)
library(Seurat)
library(hdf5r)
library(dplyr)
library(patchwork)
#library(scDblFinder)
library(DoubletFinder)
#library(SingleCellExperiment)
library(tibble)
library(biomaRt)
library(ggplot2)
library(ddqcR)
library(SummarizedExperiment)
library(valiDrops)
source("functions.R")
```

```{r}
#| include: false
seurat <- load_data_10XG(params$patient, c(1,4,8,11,14), params$directory, params$file)
list2env(seurat, envir = .GlobalEnv)
```

Add an identity with the time point

```{r}
CLL_D1_filtered$timepoint <- "D1"
CLL_D4_filtered$timepoint <- "D4"
CLL_D8_filtered$timepoint <- "D8"
CLL_D11_filtered$timepoint <- "D11"
CLL_D14_filtered$timepoint <- "D14"
```

Merge all the data filtered, in order to have one SeuratObject with all the time point for one patient (and the total cells and genes number).

```{r}
CLL_merged <- merge(CLL_D1_filtered, y = list(CLL_D4_filtered, CLL_D8_filtered,
                                                    CLL_D11_filtered, CLL_D14_filtered),
                       add.cell.ids = c("D1", "D4", "D8", "D11", "D14"), project = "TimeCourse")

CLL_merged[["RNA"]] <- JoinLayers(CLL_merged[["RNA"]])
```

Total number of cells at the beginning.

```{r}
ncol(CLL_merged)
```

## QC and filtering, valid barcodes and cells alive

This step in done on the data days merged. The tool valiDrops is a tool used for the quality control in single cell RNA seq by identifying valid barcodes and predicting whether each cell is alive or dead, based on expression profiles and quality metrics. It sequentially filters low-quality barcodes using adaptive thresholds on standard QC metrics (UMIs, features number, coding genes, ribosomal genes) and gene expression-based clustering. It improves data quality by removing noisy or dead cells without requiring manual parameter tuning (Kavaliauskaite G and Madsen JGS, 2023).

Run valiDrops

```{r}
valid <- valiDrops(CLL_merged, label_dead = TRUE)
```

Keeping the cells alive and barcodes that passed the quality control

```{r}
valid <- valid[, c("barcode", "qc.pass", "label")]
rownames(valid) <- valid$barcode
valid$barcode <- NULL
CLL_merged <- AddMetaData(CLL_merged, valid)

CLL_qc <-CLL_merged
CLL_qc <- run_umap(CLL_qc)
CLL_qc$qc_final <- ifelse(CLL_qc$qc.pass == "pass" & CLL_qc$label == "live", "TRUE", "FALSE")
```

```{r}
plot<-DimPlot(CLL_qc, group.by = "qc_final", cols = c("TRUE" = "grey80", "FALSE" = "red")) + ggtitle(paste("QC status of cells (red = failed) using \nvaliDrops tool (filtering the empty barcodes \nand dead cells,", params$patient))
plot
ggsave(paste("valiDrops_qc_", params$patient, ".jpeg"), plot)
```

Filtering

```{r}
CLL_merged <- subset(CLL_merged, subset = qc.pass == "pass" & label == "live")
```

```{r}
ncol(CLL_merged)
```

## Non coding genes removal

Features number before non-coding genes removal

```{r}
nrow(CLL_merged)
```

The non-coding genes removal is based on the database Ensembl in order to select the genes coding for proteins. The function used is explain on the file functions.R

This function accepts a Seurat object at any stage (pre- or post-processing) and returns a version of the object with all non-coding genes filtered out.

```{r}
CLL_merged <- removal_noncoding_gene(CLL_merged)
```

Features number after non-coding genes removal

```{r}
nrow(CLL_merged)
```

## Doublet removal

Number of cell before doublet removal

```{r}
ncol(CLL_merged)
```

The tool used is DoubletFinder, and it is important to run it on each sample individually rather than on aggregated data. The input for this step is a Seurat object corresponding to one sample (i.e., one patient at one time point). In this case, we use the custom function `complete_DoubletFinder` defined in the `functions.R` file. This function performs all necessary preprocessing steps prior to running DoubletFinder. The output is a new Seurat object that includes an additional metadata column indicating whether each cell is classified as a singlet or a doublet. For each day, the cell IDs and their corresponding classifications are extracted and then merged across all days.

```{r}
#| message: false
#| warning: false
#| include: false

days <- c("D1","D4","D8","D11", "D14")
results_list <- list()

for (day in days) {
  obj_name <- paste0("CLL_", day, "_filtered")
  obj <- get(obj_name)
  obj <- complete_DoubletFinder(obj)
  assign(obj_name, obj) 
  
  # Metadata extraction
  res <- obj@meta.data["doublet_finder"]
  
  # New cells name with _D
  res$cell_id <- paste0(day, "_", rownames(res))
  rownames(res) <- res$cell_id
  res$cell_id <- NULL
  
  results_list[[day]] <- res
}

# Fusion
results_multiplet <- do.call(dplyr::bind_rows, results_list)
```

Doublet/Singlet class addition in the Seurat Object metadata and removal doublet

```{r}
CLL_merged <- AddMetaData(CLL_merged, results_multiplet)
CLL_multiplet <- CLL_merged
```

Percentage calculation

```{r}
#| include: false
table_classes <- table(CLL_merged$doublet_finder)
percentages <- prop.table(table_classes) * 100

CLL_merged@meta.data %>%
  group_by(timepoint, doublet_finder) %>%
  summarise(n = n()) %>%
  mutate(percent = n / sum(n) * 100) -> timepoint_percent
```

```{r}
print(percentages)
print(timepoint_percent)
```

```{r}
CLL_merged <- subset(CLL_merged, doublet_finder == 'Singlet')
```

Identify the doublets on the UMAP

```{r}
#| include: false
CLL_multiplet <- run_umap(CLL_multiplet)

CLL_multiplet$Doublet_Status <- ifelse(CLL_multiplet$doublet_finder == "Doublet", "Doublet", "Other")
```

```{r}
DimPlot(CLL_multiplet, group.by = "Doublet_Status", cols = c("Other" = "grey80", "Doublet" = "red")) + ggtitle(paste("Doublets position with DoubletFinder \n(McGinnis, C. S. and al, 2019)", params$patient))
```

Cell number after doublets removal

```{r}
ncol(CLL_merged)
```

## Checking the quality control

Mitochondrial gene percentage calculation

```{r}
CLL_merged[["percent.mt"]] <- PercentageFeatureSet(CLL_merged, pattern = "^MT-")
```

```{r}
#| warning: false
vplot1 <-VlnPlot(CLL_merged, features = c("nFeature_RNA"))
vplot2 <-VlnPlot(CLL_merged, features = c("nCount_RNA"))
vplot3 <-VlnPlot(CLL_merged, features = c("percent.mt"))
(vplot1 / vplot2 / vplot3) + plot_annotation(
    title =paste("Violon Plots (nFeature, nCount, mitonchondrial genes percentage) \n after the QC and filtering by valiDrops tool,",params$patient))
```

## Normalization, scaling and most variable features

Normalization

```{r}
#| include: false
CLL_merged<-NormalizeData(CLL_merged)
```

Variable features. Only genes with variability are kept.

```{r}
#| warning: false
CLL_merged<-FindVariableFeatures(CLL_merged,selection.method = "vst", 
                                    nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(CLL_merged), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(CLL_merged)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

Scaling

```{r}
#| warning: false
all.genes <- rownames(CLL_merged)
CLL_merged <- ScaleData(CLL_merged, features = all.genes)
```

# Exploring

First step of visualization is to run a PCA.

```{r}
#| warning: false
CLL_merged <- RunPCA(CLL_merged, features = VariableFeatures(object = CLL_merged))
```

Ranking of principle components based on the percentage of variance explained by each one, in order to choose how many components for the representation

```{r}
#| warning: false
ElbowPlot(CLL_merged)
```

With those plots, the correlation between genes and components is shown, the PCA in the two first components and the heatmap in PC1.

```{r}
VizDimLoadings(CLL_merged, dims = 1:2, reduction = "pca")
DimPlot(CLL_merged, reduction = "pca") + NoLegend()
DimHeatmap(CLL_merged, dims = 1, cells = 500, balanced = TRUE)
```

## Clustering

Cells were clustered based on the first ten principal components. The `FindClusters` function requires a `resolution` parameter, which controls the clustering granularity, the number of clusters obtained depends directly on this value. That's why four different resolutions (0.05, 0.1, 0.2, 0.5) were tested, in order to identify the most appropriate one.

```{r}
#| message: false
#| warning: false
CLL_merged <- FindNeighbors(CLL_merged, dims = 1:10)
CLL_merged <- FindClusters(CLL_merged, resolution = params$resolution)
```

## UMAP

Run the UMAP on the resolution chosen below.

```{r}
#| warning: false
CLL_merged <- RunUMAP(CLL_merged, dims = 1:10)
DimPlot(CLL_merged, reduction = "umap")
plotumap<-DimPlot(CLL_merged, reduction = "umap")
ggsave(paste("valiDrops_umap_", params$patient, ".jpeg"), plotumap)
```

```{r}
CLL_merged$timepoint <- factor(
  CLL_merged$timepoint,
  levels = c("D1", "D4", "D8", "D11", "D14")
)

plot<-DimPlot(CLL_merged, reduction = "umap", group.by = "seurat_clusters", split.by = "timepoint") +
  ggtitle(paste("UMAP by timepoint after QC and filtering \nby valiDrops,", params$patient)) +
  theme(plot.title = element_text(hjust = 0.5))
plot
ggsave(paste("valiDrops_umap_timepoint_", params$patient, ".jpeg"), plotumap)
```

## t-SNE

```{r}
CLL_merged <- RunTSNE(CLL_merged, reduction.use = "pca", dims.use = 1:10)
plot<-TSNEPlot(CLL_merged) + ggtitle(paste("t-SNE after QC and filtering \nby valiDrops,", params$patient))
plot
ggsave(paste("valiDrops_tsne_", params$patient, ".jpeg"), plot)
```

## Bonsai

Bonsai is a data representation tool that can be applied to single-cell datasets. It reconstructs a tree that best captures the structure present in high-dimensional data (Daan Hugo de Groot, Sarah X. Morillo Leonardo, Mikhail Pachkov, Erik van Nimwegen, 2025).

In this analysis, we use the single-cell Bonsai pipeline available at <https://bonsai.unibas.ch/bonsai/>. To use it, we first extract the gene expression count matrix from the Seurat object and save it in a tsv format. This matrix is then submitted through the web interface, and the results are sent via email once the analysis is complete.

Export the count matrix to a tsv file from a Seurat object

```{r}
counts <- GetAssayData(object = CLL_merged, assay = "RNA", slot = "counts")
counts <- as.matrix(counts)
namefile=paste0("CLL_", params$patient, "_valiDrops.tsv")
write.table(counts, file = namefile, sep = "\t", quote = FALSE, col.names = NA)
```

## wnnUMAP (ADT+RNA)

```{r}
#| message: false
#| warning: false
CLL_merged <-run_adt_umap(CLL_merged)
CLL_merged <- run_wnnumap(CLL_merged, params$resolution, "RNA")
plotwnn <- DimPlot(CLL_merged, reduction = 'wnn.umap', label = TRUE, repel = TRUE, label.size = 2.5) + 
  NoLegend() + ggtitle(paste("wnnUMAP after QC and filtering \nby valiDrops,", params$patient))
plotwnn
ggsave(paste("valiDrops_wnnumap_", params$patient, ".jpeg"), plotwnn)
DefaultAssay(CLL_merged) <- 'RNA'
```

## Save the object after the pre-processing

```{r}
namepath=paste0("./CLL_", params$patient, "_valiDrops.rds")
saveRDS(CLL_merged, file = namepath)
```
